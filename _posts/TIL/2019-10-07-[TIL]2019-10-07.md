---
layout: post
title: "[TIL] 2019-10-07"
date: 2019-10-07
categories: TIL
tags: TIL
comments: true
---
## Today I Learned
- GoF(Gang of Four)의 디자인 패턴의 패턴은 총 23가지이다. (안드로이드의 holder 패턴과 viewholder 패턴은 디자인 패턴이 아님) 1995년에 나온 고전이지만 아직까지 쓰는 것은 외워두도록. 
- 하지만 패턴에 종속되면 안된다. 지금은 프로그래밍 환경과 그에 따른 방법론이 많이 변했기 때문에 안쓰는 패턴이 많다. 다만 proxy, iterator, observer, strategy는 정말 많이 쓴다고 한다.

1. 싱글턴
2. 빌더
3. 추상팩토리
    - 생성(factory)에 대한 방법을 가변적으로 구현할 수 있다.
4. 팩토리메서드
    - factory란 소프트웨어에서 무엇인가 생성하는 역할이라는 뜻으로 쓰임.
5. 프로토타입
    - 견본에 의한 생성. 어떠한 객체를 새롭게 생성하는 것이 아니라 견본을 복제하여 생성하는 것. clone의 문제점은? 3가지가 있음. 이펙티브 자바에 나옴.
6. 템플릿 메서드
    - 엄청 많이 씀. 안드로이드에서 onCreate를 호출할 때 super.onCreate를 하는 부분이 바로 템플릿 메서드임. super.onBackPressed()도 마찬가지.
7. 전략(strategy)
    - 변해야 하는 정책은 interface를 통해서 전달, 혹은 함수를 통해서 인자로 전달. setOnClickListener가 대표적인 전략임. 이것은 오버로딩/오버라이딩과는 다름. 오버로딩은 메서드의 이름이 같고 입력만 다름(컴파일 타임 다형성). 오버라이딩은 그것을 호출하는 객체가 다름(런타임 다형성). 오버라이딩은 어떤 객체가 그것을 호출하는지를 런타임에 검사함. 상속에서 부모와 자식은 반드시 is-a 관계가 성립해야 함. 컴파일 타임 다형성은 성능적인 오버헤드가 없다. 런타임 다형성은 그 자체가 오버헤드이다. kotlin에서 기본적으로 final 메소드를 만들도록 하는 것은 불필요한 상속을 방지하는 것도 있지만 성능적인 부분을 위한 것이기도 함.
8. state 상태패턴
    - 나의 상태에 따라서 동작이 바뀌는 패턴. 자바의 enum. enum의 각 항목이 state.
9. 관찰자
    - 변경을 알려주는 것. push 메시지 또한 관찰 패턴임.
10. 반복자
    - 컬렉션의 내부 구조에 상관없이 요소를 열거하는 패턴.
11. composite
    - 복합 객체는 단일 객체도 복합 객체도 포함할 수 있다.  폴더와 파일. 폴더는 복합 객체이고 파일은 단일 객체임. 폴더에는 폴더도 들어갈 수 있다.
    - 메뉴. 서브메뉴 안에 또 서브메뉴를 포함할 수 있음.
12. decorator
    - 실행중인 객체의 기능을 포함하고 싶을 때. inputStream, outputStream. 버퍼를 추가하고 싶으면 bufferedInputStream.. 등. SRT(단일 설계)를 잘 구현한 것.
    - 문제점: call이 중첩됨. 림이 생긴다? 자바에서는 io성능상의 이슈가 있음.
13. 브릿지
14. adapter
    - 각기 다른 인터페이스의 접합부 역할을 해줌. 예를 들면 리사이클러뷰에 리스트를 뿌리고 싶으면 이 어답터가 필요함.
    - 자바의 stack은 adapter로 구현되어 있음. 리스트를 한 번 감싸서 선입후출의 구조로 만든 것이 스택임.  이것은 잘못된 설계임. is-a 관계가 설립하지 않는데 상속으로 만들었기 때문.
15. mediator(중간자)
    - 라디오버튼. 여러가지 상태를 동시에 가질 수 없음. 이 상태를 유지하기 위해서는 서로의 상태를 모두 알아야 함. 1:1 대응 관계로 만들기 위해서는 복잡도가 높아짐. 그래서 중간자를 두면 복잡도를 낮추면서 상태를 감지할 수 있음
16. facade(퍼사드)
    - 레이어를 만드는 것. 인터넷에서 무언가를 다운로드받는 코드를 짠다고 해보자. C언어로 하려면 소켓연결부터 다 짜야하지만, 자바는 해당 메서드를 가져다 쓰기만 하면 됨.
    - 코드의 가독성을 높이기 위해서 중요함.
    - private 메서드의 역할: 우리는 정보 은닉이라고 배웠지만 아니다. public 메서드의 가독성을 높이기 위해서 private을 써야 한다.
17. flyweight(경량)
    - 상태를 복사하지 않고 공유하여 쓰는 것.
    - 장점: 메모리 점유를 낮춤.
    - 전제조건: 불변 객체이어야 한다.
    - COP(copy on write): 쓸 때 복제하겠다는 것. late copy.
18. proxy
    - 많이 씀.
    - 디자인 패턴의 꽃.
    - RPT, RMI
19. 책임 연쇄(chain of responsibility)
    - 예: 자식 이벤트를 클릭했을 때, 해당 이벤트가 자식이 아니라 부모에게서 발생해야 할 때.
    - 이것을 책임의 전가라고 부름.
20. 커맨드(command)
    - undo, redo를 만든다고 생각해보자. 이 명령 자체를 만들 수 없음.
    - 명령을 저장하기 위해서 명령이라는 행위 자체를 객체로 만드는 것.
21. interpreter(인터프리터)
22. 메멘토(memento)
    - 저장해야 하는 부분을 별도로 분리해서 관리해야 할 때 씀. 상태를 저장하고 상태를 복원함.
23. 비지터(visitor). 방문자패턴.
    - 컬렉션의 내부 구조에 상관없이 요소를 연산(operate)하는 패턴.
    - 많이 안쓴다.
    - 문제점: 캡슐화가 깨져 있는 디자인 패턴임. 그래서 요즘은 연산 또한 iterator로 구현함.